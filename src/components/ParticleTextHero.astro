---
/**
 * Particle Text Hero Component
 * Interactive Three.js particle system that forms "FUTURE IS NOW" text
 */

interface Props {
    text?: string;
    subtitle?: string;
}

const { 
    text = "FUTURE\nIS NOW",
    subtitle = "Interactive particle experience - move your mouse to explore"
} = Astro.props;
---

<section class="relative w-full h-screen overflow-hidden bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900">
    <!-- Three.js Container -->
    <div id="magic" class="w-full h-full cursor-crosshair"></div>
    
    <!-- Overlay Content -->
    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-end p-4 md:p-8">
        <div class="text-center text-white/80">
            <p class="text-base md:text-lg lg:text-xl mb-3 md:mb-4 font-light tracking-wide">{subtitle}</p>
            <div class="flex flex-col sm:flex-row justify-center gap-2 sm:gap-4 text-xs md:text-sm text-white/60">
                <span class="hidden sm:inline">• Click and drag to interact</span>
                <span class="sm:hidden">• Touch and drag to interact</span>
                <span>• Watch the particles dance</span>
                <span class="hidden sm:inline">• Experience the future</span>
            </div>
        </div>
    </div>
    
    <!-- Loading overlay -->
    <div id="loading-overlay" class="absolute inset-0 bg-slate-900 flex items-center justify-center z-20 transition-opacity duration-1000">
        <div class="text-center text-white">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-cyan-400 mx-auto mb-4"></div>
            <p class="text-lg font-light">Loading particle system...</p>
        </div>
    </div>
    
    <!-- Shaders -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( color * vColor, 1.0 );
            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
            if ( gl_FragColor.a < 0.01 ) discard;
        }
    </script>
</section>

<script>
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    
    const preload = () => {
        let manager = new THREE.LoadingManager();
        
        manager.onLoad = function () {
            // Hide loading overlay
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
                loadingOverlay.style.opacity = '0';
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 1000);
            }
            
            const environment = new Environment(typo, particle);
        };

        var typo = null;
        const loader = new FontLoader(manager);
        const font = loader.load(
            "https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json",
            function (font) {
                typo = font;
            }
        );
        const particle = new THREE.TextureLoader(manager).load(
            "https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png"
        );
    };

    class Environment {
        constructor(font, particle) {
            this.font = font;
            this.particle = particle;
            this.container = document.querySelector("#magic");
            
            // Detect mobile device
            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
            
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x040d20);
            this.scene.particleColor = new THREE.Color(0x040d20);
            this.createCamera();
            this.createRenderer();
            this.setup();
            this.bindEvents();
        }

        bindEvents() {
            window.addEventListener("resize", this.onWindowResize.bind(this));
        }

        setup() {
            this.createParticles = new CreateParticles(
                this.scene,
                this.font,
                this.particle,
                this.camera,
                this.renderer
            );
        }

        render() {
            this.createParticles.render();
            this.renderer.render(this.scene, this.camera);
        }

        createCamera() {
            this.camera = new THREE.PerspectiveCamera(
                65,
                this.container.clientWidth / this.container.clientHeight,
                1,
                10000
            );
            this.camera.position.set(0, 0, 100);
        }

        createRenderer() {
            // Optimize renderer settings for mobile
            const rendererOptions = {
                antialias: !this.isMobile, // Disable antialiasing on mobile for performance
                alpha: true,
                powerPreference: this.isMobile ? "low-power" : "high-performance"
            };
            
            this.renderer = new THREE.WebGLRenderer(rendererOptions);
            this.renderer.setSize(
                this.container.clientWidth,
                this.container.clientHeight
            );

            // Limit pixel ratio on mobile for better performance
            const pixelRatio = this.isMobile ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2);
            this.renderer.setPixelRatio(pixelRatio);
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.container.appendChild(this.renderer.domElement);

            this.renderer.setAnimationLoop(() => {
                this.render();
            });
        }

        onWindowResize() {
            // Debounce resize events for better performance
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(
                    this.container.clientWidth,
                    this.container.clientHeight
                );
                
                // Update mobile detection on resize
                const wasMobile = this.createParticles.isMobile;
                this.createParticles.isMobile = window.innerWidth < 768;
                
                // Recreate particles if mobile state changed for optimal performance
                if (wasMobile !== this.createParticles.isMobile) {
                    this.createParticles.data.amount = this.createParticles.isMobile ? 800 : 1500;
                    this.createParticles.data.textSize = this.createParticles.isMobile ? 12 : 16;
                    this.createParticles.data.area = this.createParticles.isMobile ? 150 : 250;
                    this.createParticles.data.particleSize = this.createParticles.isMobile ? 0.8 : 1;
                    
                    // Optionally recreate the text geometry for better mobile performance
                    if (this.createParticles.particles) {
                        this.scene.remove(this.createParticles.particles);
                        this.createParticles.createText();
                    }
                }
            }, 100);
        }
    }

    class CreateParticles {
        constructor(scene, font, particleImg, camera, renderer) {
            this.scene = scene;
            this.font = font;
            this.particleImg = particleImg;
            this.camera = camera;
            this.renderer = renderer;

            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2(-200, 200);

            this.colorChange = new THREE.Color();

            this.buttom = false;
            
            // Detect mobile device
            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

            this.data = {
                text: "FUTURE\nIS NOW",
                amount: 1500,
                particleSize: 1,
                particleColor: 0xffffff,
                textSize: 16,
                area: 250,
                ease: 0.05
            };

            this.setup();
            this.bindEvents();
        }

        setup() {
            const geometry = new THREE.PlaneGeometry(
                this.visibleWidthAtZDepth(100, this.camera),
                this.visibleHeightAtZDepth(100, this.camera)
            );
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true
            });
            this.planeArea = new THREE.Mesh(geometry, material);
            this.planeArea.visible = false;
            this.createText();
        }

        bindEvents() {
            // Mouse events
            document.addEventListener("mousedown", this.onMouseDown.bind(this));
            document.addEventListener("mousemove", this.onMouseMove.bind(this));
            document.addEventListener("mouseup", this.onMouseUp.bind(this));
            
            // Touch events for mobile
            document.addEventListener("touchstart", this.onTouchStart.bind(this), { passive: false });
            document.addEventListener("touchmove", this.onTouchMove.bind(this), { passive: false });
            document.addEventListener("touchend", this.onTouchEnd.bind(this));
        }

        onMouseDown(event) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
            vector.unproject(this.camera);
            const dir = vector.sub(this.camera.position).normalize();
            const distance = -this.camera.position.z / dir.z;
            this.currenPosition = this.camera.position
                .clone()
                .add(dir.multiplyScalar(distance));

            const pos = this.particles.geometry.attributes.position;
            this.buttom = true;
            this.data.ease = 0.01;
        }

        onMouseUp() {
            this.buttom = false;
            this.data.ease = 0.05;
        }
        
        onTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
            vector.unproject(this.camera);
            const dir = vector.sub(this.camera.position).normalize();
            const distance = -this.camera.position.z / dir.z;
            this.currenPosition = this.camera.position
                .clone()
                .add(dir.multiplyScalar(distance));

            this.buttom = true;
            this.data.ease = 0.01;
        }
        
        onTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        }
        
        onTouchEnd(event) {
            event.preventDefault();
            this.buttom = false;
            this.data.ease = 0.05;
        }

        onMouseMove(event) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        render(level) {
            const time = ((0.001 * performance.now()) % 12) / 12;
            const zigzagTime = (1 + Math.sin(time * 2 * Math.PI)) / 6;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            
            // Performance optimization: reduce update frequency on mobile
            if (this.isMobile) {
                this.frameCount = (this.frameCount || 0) + 1;
                if (this.frameCount % 2 !== 0) return; // Skip every other frame on mobile
            }

            const intersects = this.raycaster.intersectObject(this.planeArea);

            if (intersects.length > 0) {
                const pos = this.particles.geometry.attributes.position;
                const copy = this.geometryCopy.attributes.position;
                const coulors = this.particles.geometry.attributes.customColor;
                const size = this.particles.geometry.attributes.size;

                const mx = intersects[0].point.x;
                const my = intersects[0].point.y;
                const mz = intersects[0].point.z;

                for (var i = 0, l = pos.count; i < l; i++) {
                    const initX = copy.getX(i);
                    const initY = copy.getY(i);
                    const initZ = copy.getZ(i);

                    let px = pos.getX(i);
                    let py = pos.getY(i);
                    let pz = pos.getZ(i);
                    
                    // Performance optimization: reduce color calculations on mobile
                    if (!this.isMobile || i % 3 === 0) {
                        // This change white color
                        this.colorChange.setHSL(0.5, 1, 1);
                        coulors.setXYZ(
                            i,
                            this.colorChange.r,
                            this.colorChange.g,
                            this.colorChange.b
                        );
                        coulors.needsUpdate = true;

                        size.array[i] = this.data.particleSize;
                        size.needsUpdate = true;
                    }

                    let dx = mx - px;
                    let dy = my - py;
                    const dz = mz - pz;

                    const mouseDistance = this.distance(mx, my, px, py);
                    let d = (dx = mx - px) * dx + (dy = my - py) * dy;
                    const f = -this.data.area / d;

                    if (this.buttom) {
                        const t = Math.atan2(dy, dx);
                        px -= f * Math.cos(t);
                        py -= f * Math.sin(t);

                        this.colorChange.setHSL(0.5 + zigzagTime, 1.0, 0.5);
                        coulors.setXYZ(
                            i,
                            this.colorChange.r,
                            this.colorChange.g,
                            this.colorChange.b
                        );
                        coulors.needsUpdate = true;

                        if (
                            px > initX + 70 ||
                            px < initX - 70 ||
                            py > initY + 70 ||
                            py < initY - 70
                        ) {
                            this.colorChange = new THREE.Color(0x04befe);
                            coulors.setXYZ(
                                i,
                                this.colorChange.r,
                                this.colorChange.g,
                                this.colorChange.b
                            );
                            coulors.needsUpdate = true;
                        }
                    } else {
                        if (mouseDistance < this.data.area) {
                            if (i % 5 == 0) {
                                const t = Math.atan2(dy, dx);
                                px -= 0.03 * Math.cos(t);
                                py -= 0.03 * Math.sin(t);

                                this.colorChange = new THREE.Color(0x04befe);
                                coulors.setXYZ(
                                    i,
                                    this.colorChange.r,
                                    this.colorChange.g,
                                    this.colorChange.b
                                );
                                coulors.needsUpdate = true;

                                size.array[i] = this.data.particleSize / 1.2;
                                size.needsUpdate = true;
                            } else {
                                const t = Math.atan2(dy, dx);
                                px += f * Math.cos(t);
                                py += f * Math.sin(t);

                                pos.setXYZ(i, px, py, pz);
                                pos.needsUpdate = true;

                                size.array[i] = this.data.particleSize * 1.3;
                                size.needsUpdate = true;
                            }

                            if (
                                px > initX + 10 ||
                                px < initX - 10 ||
                                py > initY + 10 ||
                                py < initY - 10
                            ) {
                                this.colorChange = new THREE.Color(0x04befe);
                                coulors.setXYZ(
                                    i,
                                    this.colorChange.r,
                                    this.colorChange.g,
                                    this.colorChange.b
                                );
                                coulors.needsUpdate = true;

                                size.array[i] = this.data.particleSize / 1.8;
                                size.needsUpdate = true;
                            }
                        }
                    }

                    px += (initX - px) * this.data.ease;
                    py += (initY - py) * this.data.ease;
                    pz += (initZ - pz) * this.data.ease;

                    pos.setXYZ(i, px, py, pz);
                    pos.needsUpdate = true;
                }
            }
        }

        createText() {
            let thePoints = [];

            let shapes = this.font.generateShapes(this.data.text, this.data.textSize);
            let geometry = new THREE.ShapeGeometry(shapes);
            geometry.computeBoundingBox();

            const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
            const yMid = (geometry.boundingBox.max.y - geometry.boundingBox.min.y) / 2.85;

            geometry.center();

            let holeShapes = [];

            for (let q = 0; q < shapes.length; q++) {
                let shape = shapes[q];

                if (shape.holes && shape.holes.length > 0) {
                    for (let j = 0; j < shape.holes.length; j++) {
                        let hole = shape.holes[j];
                        holeShapes.push(hole);
                    }
                }
            }
            shapes.push.apply(shapes, holeShapes);

            let colors = [];
            let sizes = [];

            for (let x = 0; x < shapes.length; x++) {
                let shape = shapes[x];

                const amountPoints = shape.type == "Path" ? this.data.amount / 2 : this.data.amount;
                let points = shape.getSpacedPoints(amountPoints);

                points.forEach((element, z) => {
                    const a = new THREE.Vector3(element.x, element.y, 0);
                    thePoints.push(a);
                    colors.push(this.colorChange.r, this.colorChange.g, this.colorChange.b);
                    sizes.push(1);
                });
            }

            let geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
            geoParticles.translate(xMid, yMid, 0);

            geoParticles.setAttribute(
                "customColor",
                new THREE.Float32BufferAttribute(colors, 3)
            );
            geoParticles.setAttribute(
                "size",
                new THREE.Float32BufferAttribute(sizes, 1)
            );

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) },
                    pointTexture: { value: this.particleImg }
                },
                vertexShader: document.getElementById("vertexshader").textContent,
                fragmentShader: document.getElementById("fragmentshader").textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            this.particles = new THREE.Points(geoParticles, material);
            this.scene.add(this.particles);

            this.geometryCopy = new THREE.BufferGeometry();
            this.geometryCopy.copy(this.particles.geometry);
        }

        visibleHeightAtZDepth(depth, camera) {
            const cameraOffset = camera.position.z;
            if (depth < cameraOffset) depth -= cameraOffset;
            else depth += cameraOffset;

            const vFOV = (camera.fov * Math.PI) / 180;
            return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
        }

        visibleWidthAtZDepth(depth, camera) {
            const height = this.visibleHeightAtZDepth(depth, camera);
            return height * camera.aspect;
        }

        distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
    }

    // Initialize when DOM is ready
    if (
        document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)
    ) {
        preload();
    } else {
        document.addEventListener("DOMContentLoaded", preload);
    }
</script>

<style>
    #magic {
        background: linear-gradient(135deg, #040d20 0%, #0c1426 50%, #040d20 100%);
        /* Prevent scrolling issues on mobile */
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
    }
    
    /* Ensure proper cursor feedback */
    #magic canvas {
        cursor: crosshair;
        /* Prevent text selection on touch */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        /* Optimize for touch */
        touch-action: none;
    }
    
    /* Mobile-specific cursor */
    @media (hover: none) and (pointer: coarse) {
        #magic canvas {
            cursor: default;
        }
    }
    
    /* Smooth loading transition */
    #loading-overlay {
        backdrop-filter: blur(10px);
    }
    
    /* Prevent zoom on double tap on iOS */
    @media screen and (max-width: 768px) {
        #magic {
            touch-action: manipulation;
        }
    }
    
    /* Reduce motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
        #magic canvas {
            animation: none;
        }
    }
</style>